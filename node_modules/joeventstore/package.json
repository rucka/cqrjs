{
  "name": "joeventstore",
  "version": "0.5.1",
  "description": "Javascript porting of C# joliver EventStore, an event storage for event sourcing",
  "main": "main.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "mdcore": "0.1.3",
    "mongodb": "1.2.8",
    "q": "0.8.12",
    "requirejs": "2.1.1",
    "underscore": "1.4.3",
    "underscore.string": "2.3.1",
    "wrench": "1.4.2"
  },
  "devDependencies": {
    "nodeunit": "~0.7.4"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rucka/JOEventStore.git"
  },
  "keywords": [
    "nodejs",
    "javascript",
    "util",
    "cqrs",
    "server",
    "event sourcing",
    "framework",
    "eventstore",
    "joliver",
    "mongodb"
  ],
  "author": {
    "name": "Gianluca Carucci",
    "email": "gianluca@carucci.org"
  },
  "license": "MIT",
  "readmeFilename": "readme.markdown",
  "readme": "joliver EventStore node.js porting\r\n======================================================================\r\n## Disclaimer \r\nThis readme is modified from https://github.com/joliver/EventStore/blob/master/readme.markdown, in order to leave\r\nthe essence of joliver EventStore and their goal.\r\nLet's go!\r\n\r\n## Overview\r\nThe EventStore is a persistence library used to abstract different storage implementations\r\nwhen using event sourcing as storage mechanism.  Event sourcing is most closely associated\r\nwith a concept known as [CQRS](http://cqrsinfo.com).\r\n\r\n### Need Help? Have a Question?\r\nAsk your question on [Stack Overflow](http://stackoverflow.com/search?q=[cqrs]+eventstore) and tag your question with\r\nthe CQRS tag and the word \"EventStore\" in the title.\r\n\r\n### Purpose and Theory\r\nThe purpose of the EventStore is to represent a series of events as a stream.  Furthermore,\r\nit provides hooks whereby any events committed to the stream can be dispatched to interested\r\nparties.\r\n\r\nGuided by a number strategic design decisions based upon the needs of applications using event sourcing,\r\nthe EventStore is able to liberate applications from the stringent requirements often imposed by\r\ninfrastructure components.  Specifically, most CQRS-style applications read from a message queue\r\nand perform some processing.  When processing is complete, the application then commits the work\r\nto storage and publishes the completed work.\r\n\r\nThe EventStore liberates application developers from this level of infrastructure awareness and\r\nconcern by committing all work within a separate isolated atomic unit--all without using transactions.\r\nFurthermore, it does this outside of any ambient transaction from a message queue or other\r\npersistence mechanisms.  In other words, application developers are free to use virtually any\r\nmessaging queuing infrastructure, message bus (if at all), and storage engine. Each will perform\r\nits own specific task in an isolated manner with full transactional integrity all without\r\nenlisting any resources (other than a message queue) in some form of transaction.\r\n\r\nInterestingly enough, even without the presence of distributed transactions across the various resources\r\ninvolved, such as a message queue and persistent storage, the EventStore is able to ensure a fully\r\ntransactional experience.  This is achieved by breaking apart a distributed transaction into smaller\r\npieces and performing each one individually.  This is one of the primary goals and motivations in the\r\nunderlying model found in the EventStore.  Thus each message delivered by the queuing infrastructure is\r\nmade to be idempotent, even though the message may be delivered multiple times, as per message queue\r\n\"at-least-once\" guarantees.  Following this, the EventStore is able to ensure that all events committed\r\nare always dispatched to any messaging infrastructure.\r\n\r\n## Supported Storage Engines\r\n\r\n### Relational Databases\r\n[Planned] MySQL 5.0 (or later)  \r\n\r\n### Cloud-based Databases (relational or otherwise)\r\n[Planned] Microsoft SQL Azure  \r\n[Planned] Amazon RDS (MySQL)  \r\n[Planned] Amazon RDS (Oracle)  \r\n[Planned] Azure Tables/Blobs  \r\n[Planned] Amazon SimpleDB/S3  \r\n\r\n### Document Databases\r\n[Planned] RavenDB r322 (or later)  \r\n[Complete] MongoDB 1.6 (or later)  \r\n[Complete] In Memory (only for test purpose)  \r\n\r\n### File System\r\n[Planned] node.js API  \r\n \r\n\r\n## Project Goals\r\n* Node js support  \r\n* Cloud platform support  \r\n* Support more storage engines than any other event storage implementation  \r\n* Easily support virtually any storage engine (NoSQL, etc.)  \r\n* Avoid dependence upon Transactions while maintaining full data integrity  \r\n* Full test coverage of storage implementations  \r\n* Easily hook into any bus implementation (NServiceBus, MassTransit, etc.)  \r\n* Synchronous and asynchronous dispatching of events  \r\n* Support storage instance created by C# joliver EventStore \r\n* Multi-thread safe  \r\n* Fluent builder\r\n* Support CommonJs module management\r\n* Take advantage of promise pattern (based on Q library)\r\n\r\n## Dependencies\r\n* nodeunit\r\n* mongodb\r\n* q\r\n* requirejs\r\n* underscore\r\n* underscore.string \r\n* wrench\r\n\r\n## Running\r\nIn your project simply run npm install joeventstore from node console then require('joeventstore') from your node.js file.\r\n\r\n## Using the EventStore\r\n\t\tvar EventStore = require('joeventstore');\r\n\r\n                EventStore.\r\n                    Wireup.\r\n                    Init().\r\n                    usingMongoPersistence('ConnectionString of mongo db').\r\n                    usingAsynchronousDispatchScheduler().\r\n                    dispatchTo(new EventStore.Dispatcher.DelegateMessageDispatcher(my_NServiceBus_Or_MassTransit_OrEven_WCF_Adapter_Code)).\r\n                    build().\r\n                    done(run).\r\n                    fail(function (e) {\r\n\t\t\t//Manage error\r\n                    });\r\n\r\n/* NOTE: This following is merely *example* code. */\r\n\t\t\t\r\n\t\tfunction run (store) {\r\n\t\t\t// some business code here\r\n\t\t\t\r\n\t\t\tstore.\r\n\t\t\tcreateStream(myMessage.customerId).\r\n                        done(function(stream) {\r\n                            stream.add(new EventStore.EventMessage({body : myMessage}));\r\n                            return stream.\r\n                                commitChanges(myMessage.messageId).\r\n                                done();\r\n                        }).\r\n\t\t\topenStream(myMessage.customerId, 0, Number.MAX_VALUE)).\r\n\t\t\tdone(function (stream) {\r\n\t\t\t\tvar event;\r\n\t\t\t\tfor (event n stream.committedEvents) {\r\n\t\t\t\t\t// business processing...\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}).\r\n\t\t\tfail(function (e) {\r\n\t\t\t\t//Manage error...\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t/* NOTE: This following is merely *example* code. */\r\n\r\n\tusing (store)\r\n\t{\r\n\t\t// some business code here\r\n\t\tusing (var stream = store.CreateStream(myMessage.CustomerId))\r\n\t\t{\r\n\t\t\tstream.Add(new EventMessage { Body = myMessage });\r\n\t\t\tstream.CommitChanges(myMessage.MessageId);\r\n\t\t}\r\n\t\t\r\n\t\tusing (var stream = store.OpenStream(myMessage.CustomerId, 0, int.MaxValue))\r\n\t\t{\r\n\t\t\tforeach (var @event in stream.CommittedEvents)\r\n\t\t\t{\r\n\t\t\t\t// business processing...\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nFor a more complete example, please see ...\r\n\r\n## Running the Unit test example\r\n",
  "_id": "joeventstore@0.5.1",
  "_from": "joeventstore"
}
